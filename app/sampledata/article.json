{
  "rendered_body": "<p>Firebaseのrealtime databaseはいわゆるNoSQLであり，馴染みが薄い人が多いとともに，一般に流布している情報はふわっとしていてわかりづらい．<br>\n山に篭って修行していたらある程度知見が溜まってきたため，下山して共有する．</p>\n\n<p><strong>追記：</strong><br>\n新しいdbが発表されたので雑感書きました．<br>\n<a href=\"https://qiita.com/Yatima/items/54ea22d0cea1acc6cbcb\" id=\"reference-f782d6f543f725e78cf3\">Firebase RTDB + GCP datastore = Firestoreについて第一印象</a></p>\n\n<h1>\n<span id=\"tldr\" class=\"fragment\"></span><a href=\"#tldr\"><i class=\"fa fa-link\"></i></a>tl;dr</h1>\n\n<p><strong>割り切れ！</strong><br>\n<strong>ユーザの見えるままに作れ！</strong><br>\nそれ以外の細末は下記参照</p>\n\n<h1>\n<span id=\"大原則その1割り切り\" class=\"fragment\"></span><a href=\"#%E5%A4%A7%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE1%E5%89%B2%E3%82%8A%E5%88%87%E3%82%8A\"><i class=\"fa fa-link\"></i></a>大原則その1：割り切り</h1>\n\n<p>これは特にRDB勢に気をつけていただきたい．<br>\n我々は少し気を抜くと，<strong>つい正規化したがり屋さん</strong>になってしまう．<br>\n（その意味では，むしろ開発経験が少ない人のほうが習得しやすいかもしれない）</p>\n\n<p>Firebaseにおいて<strong>正規化はほぼ無駄</strong>と思ってもらっていい．<br>\n（理由は後述）<br>\n頑として非正規化を貫くべきだ（割り切り）．</p>\n\n<p>では，どう非正規化しろと言うのか．<br>\n巷では良く「ネストを浅くしろ」だの「非正規化しろ」だの言われるが，<strong>どのくらいどうすりゃいいんだよ！</strong></p>\n\n<h1>\n<span id=\"大原則その2ユーザの見えるままに設計する\" class=\"fragment\"></span><a href=\"#%E5%A4%A7%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE2%E3%83%A6%E3%83%BC%E3%82%B6%E3%81%AE%E8%A6%8B%E3%81%88%E3%82%8B%E3%81%BE%E3%81%BE%E3%81%AB%E8%A8%AD%E8%A8%88%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>大原則その2：ユーザの見えるままに設計する</h1>\n\n<p>これである．<br>\nだいたいまずこれで解決できる．</p>\n\n<p>つまりまず<strong>ビューありき</strong>なのだ（割り切り）．<br>\n<strong>dbを先に設計してはならない．</strong><br>\n（ビューを変更するときどうするか，は後述）</p>\n\n<p>なぜそうしたほうがいいのか？</p>\n\n<h2>\n<span id=\"コードはシンプルなほうがいい\" class=\"fragment\"></span><a href=\"#%E3%82%B3%E3%83%BC%E3%83%89%E3%81%AF%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AA%E3%81%BB%E3%81%86%E3%81%8C%E3%81%84%E3%81%84\"><i class=\"fa fa-link\"></i></a>コードはシンプルなほうがいい</h2>\n\n<p>当然と言えば当然である．<br>\nスパゲッティ遊びしたい人は少数だろう．</p>\n\n<p>実は<strong>ビューありきでdb設計することによって，コードをシンプルにできる</strong>のだ．</p>\n\n<p>勘のいいかたはおわかりだろうが，dbからread後の処理が最低限で済む．<br>\nある意味<a href=\"https://ja.wikipedia.org/wiki/%E6%99%82%E9%96%93%E3%81%A8%E7%A9%BA%E9%96%93%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95\" rel=\"nofollow noopener\" target=\"_blank\">時間と空間のトレードオフ</a>に近いものと思って良いだろう．</p>\n\n<p>（知らない人には申し訳ないが）js界隈で話題になりがちなVuexやFlux, Reduxのような状態管理もほぼ不要となる（割り切り．詳細後述）．</p>\n\n<p>あるいはもっと深い理由として，こんなものがある．</p>\n\n<h2>\n<span id=\"システム全体としての効率化\" class=\"fragment\"></span><a href=\"#%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%85%A8%E4%BD%93%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E5%8A%B9%E7%8E%87%E5%8C%96\"><i class=\"fa fa-link\"></i></a>システム全体としての効率化</h2>\n\n<p>実ユーザにおいては，圧倒的に書き込み数＜＜読み込み数である．<br>\n従って，効率化する（システム全体のパフォーマンスを上げる）ためには，なるべく<strong>読み込みをスピーディにするのが理に適っている</strong>．</p>\n\n<p>極端にも見える「ユーザの見えるままに」アプローチが確立された背景として，このようなことが挙げられるわけだ．<br>\nこれらを踏まえると，むしろ従来の考え方を持ち込むのは害悪にしかならないことがわかる（割り切り）．</p>\n\n<p>「ユーザの見えるままに」を踏まえたところで，もう少し細かい原則を見ていこう．</p>\n\n<h1>\n<span id=\"原則\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87\"><i class=\"fa fa-link\"></i></a>原則</h1>\n\n<h2>\n<span id=\"原則その1dbはツリー状\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE1db%E3%81%AF%E3%83%84%E3%83%AA%E3%83%BC%E7%8A%B6\"><i class=\"fa fa-link\"></i></a>原則その1：dbはツリー状</h2>\n\n<p>json形式である．<br>\nというのは自明だが，key内にスラッシュが含まれていた場合は，その階層まで潜ると解釈される．</p>\n\n<div class=\"code-frame\" data-lang=\"json\">\n<div class=\"code-lang\"><span class=\"bold\">slashed.json</span></div>\n<div class=\"highlight\"><pre><span class=\"p\">{</span><span class=\"s2\">\"users/XXXXX/name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"yatima\"</span><span class=\"p\">}</span><span class=\"w\">\n</span></pre></div>\n</div>\n\n<p>とwriteすると</p>\n\n<div class=\"code-frame\" data-lang=\"json\">\n<div class=\"code-lang\"><span class=\"bold\">nested.json</span></div>\n<div class=\"highlight\"><pre><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"s2\">\"users\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"s2\">\"XXXXX\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"s2\">\"name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"yatima\"</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></pre></div>\n</div>\n\n<p>として反映される．</p>\n\n<h2>\n<span id=\"原則その2ノード以下まるごとread\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE2%E3%83%8E%E3%83%BC%E3%83%89%E4%BB%A5%E4%B8%8B%E3%81%BE%E3%82%8B%E3%81%94%E3%81%A8read\"><i class=\"fa fa-link\"></i></a>原則その2：ノード以下まるごとread</h2>\n\n<p>課金やパフォーマンスとの関与が大きい話ではある（基本的に<a href=\"https://firebase.google.com/pricing/\" rel=\"nofollow noopener\" target=\"_blank\">read時のダウンロードサイズに対して従量課金</a>）．</p>\n\n<p>readでは，<code>.ref()</code>で指定したノードそれ以下の全てのデータを取得する．</p>\n\n<div class=\"code-frame\" data-lang=\"js\">\n<div class=\"code-lang\"><span class=\"bold\">fetch-good.js</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">const</span> <span class=\"nx\">db</span> <span class=\"o\">=</span> <span class=\"nx\">firebase</span><span class=\"p\">.</span><span class=\"nx\">database</span><span class=\"p\">()</span>\n<span class=\"kd\">const</span> <span class=\"nx\">hogeRef</span> <span class=\"o\">=</span> <span class=\"nx\">db</span><span class=\"p\">.</span><span class=\"nx\">ref</span><span class=\"p\">(</span><span class=\"s1\">'hoge'</span><span class=\"p\">)</span>\n<span class=\"nx\">hogeRef</span><span class=\"p\">.</span><span class=\"nx\">on</span><span class=\"p\">(...</span><span class=\"err\">省略</span><span class=\"p\">...)</span>\n</pre></div>\n</div>\n\n<p>とすると，<code>/hoge/</code>以下のみを取得する．</p>\n\n<div class=\"code-frame\" data-lang=\"js\">\n<div class=\"code-lang\"><span class=\"bold\">fetch-yabai.js</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">const</span> <span class=\"nx\">db</span> <span class=\"o\">=</span> <span class=\"nx\">firebase</span><span class=\"p\">.</span><span class=\"nx\">database</span><span class=\"p\">()</span>\n<span class=\"kd\">const</span> <span class=\"nx\">dbRef</span> <span class=\"o\">=</span> <span class=\"nx\">db</span><span class=\"p\">.</span><span class=\"nx\">ref</span><span class=\"p\">()</span>\n<span class=\"nx\">dbRef</span><span class=\"p\">.</span><span class=\"nx\">child</span><span class=\"p\">(</span><span class=\"s1\">'hoge'</span><span class=\"p\">).</span><span class=\"nx\">on</span><span class=\"p\">(...</span><span class=\"err\">省略</span><span class=\"p\">...)</span>\n</pre></div>\n</div>\n\n<p>とすると全部ごそっと取得することになり，悲しみが生まれる．</p>\n\n<p>ただしクエリを含めた場合は，それに該当する分のみ取得される．</p>\n\n<h2>\n<span id=\"原則その3連番は使わない\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE3%E9%80%A3%E7%95%AA%E3%81%AF%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a>原則その3：連番は使わない</h2>\n\n<p>例えばカウンタなどで，ほぼ同時にwriteが行われたとすると，残念なことになる．<br>\n（一人目が書き込み終わる前に二人目が読み込んでしまうと，二人ともカウンタを1増やしたつもりが最終的に1しか増えない）<br>\n<code>.push()</code>を使うと，<strong>一意なIDをkeyとして書き込み</strong>できる．</p>\n\n<div class=\"code-frame\" data-lang=\"js\">\n<div class=\"code-lang\"><span class=\"bold\">push.js</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">const</span> <span class=\"nx\">db</span> <span class=\"o\">=</span> <span class=\"nx\">firebase</span><span class=\"p\">.</span><span class=\"nx\">database</span><span class=\"p\">()</span>\n<span class=\"kd\">const</span> <span class=\"nx\">hogeRef</span> <span class=\"o\">=</span> <span class=\"nx\">db</span><span class=\"p\">.</span><span class=\"nx\">ref</span><span class=\"p\">(</span><span class=\"s1\">'hoge'</span><span class=\"p\">)</span>\n<span class=\"nx\">hogeRef</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"s1\">'fuga'</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n\n<p>と書き込むと</p>\n\n<div class=\"code-frame\" data-lang=\"json\">\n<div class=\"code-lang\"><span class=\"bold\">db.json</span></div>\n<div class=\"highlight\"><pre><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"s2\">\"hoge\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"s2\">\"&lt;XXX-unique-id-XXX&gt;\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"fuga\"</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></pre></div>\n</div>\n\n<p>となる．</p>\n\n<p>逆に言えば，<code>.push()</code>を使わない場合は<strong>変に上書きされても問題ない前提で</strong>開発すべきである．</p>\n\n<h2>\n<span id=\"原則その31配列を使わない\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE31%E9%85%8D%E5%88%97%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a>原則その3.1：配列を使わない</h2>\n\n<p>その3と似た理由で，配列（Array）は推奨されない．<br>\n連想配列（Object）に自動で変換されるが，その際に<strong>keyが連番で割り当てられてしまう</strong>からである．</p>\n\n<h2>\n<span id=\"原則その4一貫性のある同時書き込み\" class=\"fragment\"></span><a href=\"#%E5%8E%9F%E5%89%87%E3%81%9D%E3%81%AE4%E4%B8%80%E8%B2%AB%E6%80%A7%E3%81%AE%E3%81%82%E3%82%8B%E5%90%8C%E6%99%82%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF\"><i class=\"fa fa-link\"></i></a>原則その4：一貫性のある同時書き込み</h2>\n\n<p>単に<strong>同時書き込みするだけで一貫性が保たれる</strong>仕様である．</p>\n\n<div class=\"code-frame\" data-lang=\"js\">\n<div class=\"code-lang\"><span class=\"bold\">multi-path-write.js</span></div>\n<div class=\"highlight\"><pre><span class=\"kd\">const</span> <span class=\"nx\">db</span> <span class=\"o\">=</span> <span class=\"nx\">firebase</span><span class=\"p\">.</span><span class=\"nx\">database</span><span class=\"p\">()</span>\n<span class=\"kd\">const</span> <span class=\"nx\">dbRef</span> <span class=\"o\">=</span> <span class=\"nx\">db</span><span class=\"p\">.</span><span class=\"nx\">ref</span><span class=\"p\">()</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">newPost</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"na\">hoge</span><span class=\"p\">:</span> <span class=\"s2\">\"fuga\"</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">let</span> <span class=\"nx\">updates</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"nx\">updates</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">newPost</span>\n<span class=\"nx\">updates</span><span class=\"p\">[</span><span class=\"s1\">'bar'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">newPost</span>\n<span class=\"nx\">dbRef</span><span class=\"p\">.</span><span class=\"nx\">update</span><span class=\"p\">(</span><span class=\"nx\">updates</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n\n<p>とすると</p>\n\n<div class=\"code-frame\" data-lang=\"json\">\n<div class=\"code-lang\"><span class=\"bold\">db.json</span></div>\n<div class=\"highlight\"><pre><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"s2\">\"foo\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"s2\">\"hoge\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"fuga\"</span><span class=\"w\">\n  </span><span class=\"p\">},</span><span class=\"w\">\n  </span><span class=\"s2\">\"bar\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"s2\">\"hoge\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"fuga\"</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></pre></div>\n</div>\n\n<p>となる．<br>\nサーバ側でvalidateすることも可能だが，不要だとは思われる．一応示しておく；</p>\n\n<div class=\"code-frame\" data-lang=\"json\">\n<div class=\"code-lang\"><span class=\"bold\">consistency.rules.json</span></div>\n<div class=\"highlight\"><pre><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"s2\">\"test\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"s2\">\".write\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"true\"</span><span class=\"p\">,</span><span class=\"w\">\n    </span><span class=\"s2\">\"foo\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"s2\">\".validate\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"true\"</span><span class=\"w\">\n    </span><span class=\"p\">},</span><span class=\"w\">\n    </span><span class=\"s2\">\"bar\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"s2\">\".validate\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"newData.val() == newData.parent().child('foo').val()\"</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></pre></div>\n</div>\n\n<p>間違っても<strong><code>.transaction()</code>など使ってはならない</strong>．<br>\n（一ノードに対してしか使えない＝rootに近いノードを指定するハメになる，そして<a href=\"https://firebase.google.com/docs/reference/js/firebase.database.Reference#transaction\" rel=\"nofollow noopener\" target=\"_blank\">トランザクションはreadが発生</a>する ⇒ 諭吉ジャブジャブ，性能にも影響）</p>\n\n<p>と，比較的重要な原則についても紹介してきたが，いずれにせよあくまで大原則に沿った話である．<br>\n大原則が通用しない場合はどうすべきだろうか．</p>\n\n<h1>\n<span id=\"大原則が通用しない時\" class=\"fragment\"></span><a href=\"#%E5%A4%A7%E5%8E%9F%E5%89%87%E3%81%8C%E9%80%9A%E7%94%A8%E3%81%97%E3%81%AA%E3%81%84%E6%99%82\"><i class=\"fa fa-link\"></i></a>大原則が通用しない時</h1>\n\n<h2>\n<span id=\"ビューが強く動的に生成される\" class=\"fragment\"></span><a href=\"#%E3%83%93%E3%83%A5%E3%83%BC%E3%81%8C%E5%BC%B7%E3%81%8F%E5%8B%95%E7%9A%84%E3%81%AB%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%82%8B\"><i class=\"fa fa-link\"></i></a>ビューが強く動的に生成される</h2>\n\n<p>ここでの動的とは，静的ファイルが準備されていないという程度の意味ではない．<br>\n検索のような，ユーザの入力を元にビューを変化させたい，そういったニュアンスである．</p>\n\n<h3>\n<span id=\"検索\" class=\"fragment\"></span><a href=\"#%E6%A4%9C%E7%B4%A2\"><i class=\"fa fa-link\"></i></a>検索</h3>\n\n<p>検索には，<a href=\"https://www.algolia.com/\" rel=\"nofollow noopener\" target=\"_blank\">Algolia</a>という外部サービスを利用する（割り切り）．<br>\nFirebase公式より<a href=\"https://github.com/firebase/functions-samples/tree/master/fulltext-search\" rel=\"nofollow noopener\" target=\"_blank\">連携サンプル</a>も提示されている．<br>\nただしどうやらこのサービスはORやワイルドカードなどは使えないように見える．</p>\n\n<p>他にも<a href=\"https://github.com/firebase/flashlight\" rel=\"nofollow noopener\" target=\"_blank\">Flashlight</a>というElasticSearchとの連携があったりなかったりする．<br>\nワイルドカードは使えるとのことだが，公開されているサンプルはうまく動かない．</p>\n\n<h3>\n<span id=\"フィルタ\" class=\"fragment\"></span><a href=\"#%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF\"><i class=\"fa fa-link\"></i></a>フィルタ</h3>\n\n<p>フィルタに関しては内部で解決可能と思われる．<br>\n基本的にはフィルタのパターン数に応じ対策も変わる．<br>\nざっくり言って，</p>\n\n<p>フィルタのパターン数が多いならば，インデックスを貼る．<br>\n必要があればクライアント側で集合演算も行う．<br>\n（ANDのみならインデックス貼りまくるだけで可能だが，ORがあると厳しい）<br>\nJavaScriptなら<a href=\"https://lodash.com/docs/4.17.4\" rel=\"nofollow noopener\" target=\"_blank\">lodash</a>など使うと良い．</p>\n\n<p>フィルタのパターン数がそこまで多くないならば，クエリを駆使する．<br>\nクエリについては，公式で良い解説動画がある（日本語字幕付き）．<br>\n<a href=\"https://youtu.be/sKFLI5FOOHs?t=9m2s\" rel=\"nofollow noopener\" target=\"_blank\">Common SQL Queries converted for the Firebase Database - The Firebase Database For SQL Developers #4</a><br>\nhackyな手法にも見えるが，性能に大きな影響を与えないためのFirebaseの流儀である．</p>\n\n<p>詳細は後述しよう．</p>\n\n<h2>\n<span id=\"そもそもビューがない\" class=\"fragment\"></span><a href=\"#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82%E3%83%93%E3%83%A5%E3%83%BC%E3%81%8C%E3%81%AA%E3%81%84\"><i class=\"fa fa-link\"></i></a>そもそもビューがない</h2>\n\n<p>もし<a href=\"https://firebase.google.com/products/functions/\" rel=\"nofollow noopener\" target=\"_blank\">Functions</a>や他サーバなどから機械的にreadする必要がある場合は，「readする時使いやすいように」で良いと思われる．<br>\nなるべく事前に準備しておくという意味で，「ユーザの見えるままに」とは共通する．</p>\n\n<p>機械によるreadもなく，保存自体が主な目的の場合は（ログなど？），まぁ好きにしたらいい．</p>\n\n<h1>\n<span id=\"レシピ加筆中\" class=\"fragment\"></span><a href=\"#%E3%83%AC%E3%82%B7%E3%83%94%E5%8A%A0%E7%AD%86%E4%B8%AD\"><i class=\"fa fa-link\"></i></a>レシピ（加筆中）</h1>\n\n<h2>\n<span id=\"カウンタ\" class=\"fragment\"></span><a href=\"#%E3%82%AB%E3%82%A6%E3%83%B3%E3%82%BF\"><i class=\"fa fa-link\"></i></a>カウンタ</h2>\n\n<p>IDを数える．</p>\n\n<h2>\n<span id=\"ページネーション\" class=\"fragment\"></span><a href=\"#%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%8D%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3\"><i class=\"fa fa-link\"></i></a>ページネーション</h2>\n\n<p>クエリで良い．</p>\n\n<h2>\n<span id=\"フィルタ-1\" class=\"fragment\"></span><a href=\"#%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF-1\"><i class=\"fa fa-link\"></i></a>フィルタ</h2>\n\n<h2>\n<span id=\"検索-1\" class=\"fragment\"></span><a href=\"#%E6%A4%9C%E7%B4%A2-1\"><i class=\"fa fa-link\"></i></a>検索</h2>\n\n<h1>\n<span id=\"よく言われるアレ気付き次第追記\" class=\"fragment\"></span><a href=\"#%E3%82%88%E3%81%8F%E8%A8%80%E3%82%8F%E3%82%8C%E3%82%8B%E3%82%A2%E3%83%AC%E6%B0%97%E4%BB%98%E3%81%8D%E6%AC%A1%E7%AC%AC%E8%BF%BD%E8%A8%98\"><i class=\"fa fa-link\"></i></a>よく言われるアレ（気付き次第追記）</h1>\n\n<h2>\n<span id=\"ビューとdbを密結合させたらビューを変更する時に不便\" class=\"fragment\"></span><a href=\"#%E3%83%93%E3%83%A5%E3%83%BC%E3%81%A8db%E3%82%92%E5%AF%86%E7%B5%90%E5%90%88%E3%81%95%E3%81%9B%E3%81%9F%E3%82%89%E3%83%93%E3%83%A5%E3%83%BC%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B%E6%99%82%E3%81%AB%E4%B8%8D%E4%BE%BF\"><i class=\"fa fa-link\"></i></a>「ビューとdbを密結合させたらビューを変更する時に不便」</h2>\n\n<p>多くは見た目の変更で，扱うデータ自体が変更されることは少ないだろう．<br>\n変更されたところで，構造を修正する<strong>バッチを回せば済む</strong>話だ（割り切り）．</p>\n\n<h2>\n<span id=\"非正規化が理想なのはわかるけどでも現実的には正規化したほうがいいよね\" class=\"fragment\"></span><a href=\"#%E9%9D%9E%E6%AD%A3%E8%A6%8F%E5%8C%96%E3%81%8C%E7%90%86%E6%83%B3%E3%81%AA%E3%81%AE%E3%81%AF%E3%82%8F%E3%81%8B%E3%82%8B%E3%81%91%E3%81%A9%E3%81%A7%E3%82%82%E7%8F%BE%E5%AE%9F%E7%9A%84%E3%81%AB%E3%81%AF%E6%AD%A3%E8%A6%8F%E5%8C%96%E3%81%97%E3%81%9F%E3%81%BB%E3%81%86%E3%81%8C%E3%81%84%E3%81%84%E3%82%88%E3%81%AD\"><i class=\"fa fa-link\"></i></a>「非正規化が理想なのはわかるけど，でも現実的には正規化したほうがいいよね」</h2>\n\n<p>これもなるべくなら避けるべきだ（割り切り）．<br>\nというより，上述した特殊な場合以外は現実的に問題ないはずである．</p>\n\n<p>再度になるが，これまで培ってきた感覚で「正規化したほうがよさそう」は避けたほうが良い．<br>\nコードが複雑になり，パフォーマンスにも影響が出かねない．</p>\n\n<h2>\n<span id=\"平坦化しろ\" class=\"fragment\"></span><a href=\"#%E5%B9%B3%E5%9D%A6%E5%8C%96%E3%81%97%E3%82%8D\"><i class=\"fa fa-link\"></i></a>「平坦化しろ」</h2>\n\n<p>自分が検証した限りでは，単にdbのネストが深いからといって，パフォーマンスが落ちることはなさそうである．<br>\nそのため，「平坦化する」ということ自体をメインの目標に掲げるのは本質的でない．</p>\n\n<p>目指すはあくまで「ユーザの見えるままに」とすべきである．</p>\n\n<p>「ネストの度に検索がかかるのでは」と思ったかたは鋭い．<br>\nRDBをわかっていらっしゃる．</p>\n\n<p>realtime databaseでは，jsonのkeyに対してはインデックスが貼られるのだ．<br>\nvalueに対しても，インデックスを指定して貼ることが可能（性能に影響するとアラート出るので，それからで遅くない）．</p>\n\n<p>やはりあくまで中心は「ユーザの見えるままに」である．</p>\n\n<h2>\n<span id=\"クエリが貧弱\" class=\"fragment\"></span><a href=\"#%E3%82%AF%E3%82%A8%E3%83%AA%E3%81%8C%E8%B2%A7%E5%BC%B1\"><i class=\"fa fa-link\"></i></a>「クエリが貧弱」</h2>\n\n<p>おわかりのかたもいると思うが，そもそも基本的にクエリは最低限でよいのだ．<br>\ndbをreadした時点で，ビューに即した形になっているのだから．</p>\n\n<h2>\n<span id=\"値段高い\" class=\"fragment\"></span><a href=\"#%E5%80%A4%E6%AE%B5%E9%AB%98%E3%81%84\"><i class=\"fa fa-link\"></i></a>「値段高い」</h2>\n\n<p><a href=\"https://qiita.com/Yatima/items/8a54acc8fda3e5fce741#%E3%81%A7%E3%82%82%E3%81%8A%E9%AB%98%E3%81%84%E3%82%93%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%82%84%E3%81%A3%E3%81%B1%E3%82%8Amysql%E3%81%AE%E3%81%BB%E3%81%86%E3%81%8C\">のちほど</a>．</p>\n\n<h2>\n<span id=\"phpと組み合わせたい\" class=\"fragment\"></span><a href=\"#php%E3%81%A8%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%9F%E3%81%84\"><i class=\"fa fa-link\"></i></a>「PHPと組み合わせたい」</h2>\n\n<p>なるべく避けるべき（割り切り）．</p>\n\n<p>既存の技術を使わないのはもったいない，あるいは不安と思うかもしれない．<br>\nしかしFirebaseはシンプルなシステム構成にしてこそ真価が発揮される．<br>\n<strong>連携間の相性に悩まされることがなくなる</strong>わけだ．<br>\nあるいは<strong>データ変換やAPIなど余計なことに煩わされなくなる</strong>．<br>\n当記事に記すような考え方が身についてしまえば，<strong>学習コストも低い</strong>．</p>\n\n<p>ぜひ0から始める気持ちで臨んでほしい（割り切り）．<br>\nもちろん，RubyやPythonだろうが同様である．</p>\n\n<h1>\n<span id=\"よく言われないアレ\" class=\"fragment\"></span><a href=\"#%E3%82%88%E3%81%8F%E8%A8%80%E3%82%8F%E3%82%8C%E3%81%AA%E3%81%84%E3%82%A2%E3%83%AC\"><i class=\"fa fa-link\"></i></a>よく言われないアレ</h1>\n\n<h2>\n<span id=\"tips集\" class=\"fragment\"></span><a href=\"#tips%E9%9B%86\"><i class=\"fa fa-link\"></i></a>tips集</h2>\n\n<h3>\n<span id=\"削除時にはnullをwriteする\" class=\"fragment\"></span><a href=\"#%E5%89%8A%E9%99%A4%E6%99%82%E3%81%AB%E3%81%AFnull%E3%82%92write%E3%81%99%E3%82%8B\"><i class=\"fa fa-link\"></i></a>削除時にはnullをwriteする</h3>\n\n<p><code>.set()</code>や<code>.update()</code>，<code>.push()</code>でundefinedは送れない．<br>\n<code>.remove()</code>もあるが，<strong>複数箇所の削除はできない</strong>のでいまいち．</p>\n\n<h3>\n<span id=\"一度のみのreadにはonce\" class=\"fragment\"></span><a href=\"#%E4%B8%80%E5%BA%A6%E3%81%AE%E3%81%BF%E3%81%AEread%E3%81%AB%E3%81%AFonce\"><i class=\"fa fa-link\"></i></a>一度のみのreadには<code>.once()</code>\n</h3>\n\n<p>上記の通りである．</p>\n\n<h3>\n<span id=\"クエリを使うならchild_added\" class=\"fragment\"></span><a href=\"#%E3%82%AF%E3%82%A8%E3%83%AA%E3%82%92%E4%BD%BF%E3%81%86%E3%81%AA%E3%82%89child_added\"><i class=\"fa fa-link\"></i></a>クエリを使うなら<code>child_added</code>\n</h3>\n\n<p>read時には<code>value</code>を使う（例えば<code>.on('value', ...)</code>のように）と手軽のように思えるが，実際は<code>child_added</code>のほうが良い．<br>\n後者ならば，<a href=\"https://howtofirebase.com/firebase-data-modeling-939585ade7f4\" rel=\"nofollow noopener\" target=\"_blank\"><strong>順番の整った状態で取得できる</strong></a>ためである．<br>\n前者だとクライアント側で並び替えする必要がある．</p>\n\n<p><code>child_changed</code>などもいちいち書かなければならない？<br>\n例えば<a href=\"https://github.com/vuejs/vuefire\" rel=\"nofollow noopener\" target=\"_blank\">Vuefire</a>のような，フレームワークと紐付けしてくれる便利なライブラリがある．</p>\n\n<h2>\n<span id=\"正規化は無駄\" class=\"fragment\"></span><a href=\"#%E6%AD%A3%E8%A6%8F%E5%8C%96%E3%81%AF%E7%84%A1%E9%A7%84\"><i class=\"fa fa-link\"></i></a>正規化は無駄</h2>\n\n<p>先に謝っておく．無駄は言い過ぎた．<br>\nしかし総じてメリットが上回ることは多くないと思われる．</p>\n\n<p>慣れ以外でのメリットは，高々，容量を節約できるくらいと思われる．<br>\n正規化したところでクエリが貧弱なため，まともに使うには苦労する．<br>\nこの後に示す，グローバル的な状態管理も欲しくなってくる．<br>\nコードが複雑化するのは代償として大きい．</p>\n\n<h2>\n<span id=\"状態管理は不要\" class=\"fragment\"></span><a href=\"#%E7%8A%B6%E6%85%8B%E7%AE%A1%E7%90%86%E3%81%AF%E4%B8%8D%E8%A6%81\"><i class=\"fa fa-link\"></i></a>状態管理は不要</h2>\n\n<p>ビューに即したデータ構造を持たせるのだから，基本的にはVuexやFlux, Reduxのような状態管理（いろいろな場面でデータを共有する仕組み）は不要．<br>\nせいぜいユーザ情報程度だろう．</p>\n\n<p>firebase自体もローカルでデータ保持することを考えると，無駄が多い．</p>\n\n<h2>\n<span id=\"ベストなjsフレームワーク\" class=\"fragment\"></span><a href=\"#%E3%83%99%E3%82%B9%E3%83%88%E3%81%AAjs%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF\"><i class=\"fa fa-link\"></i></a>ベストなjsフレームワーク</h2>\n\n<p>dbの話なのにjsのフレームワークまで踏み込むのもアレだが，ビューとも密接な関係にあるため触れておく．</p>\n\n<p>公式ではAngularが話題に挙がりやすいが，上記の状態管理機能などももりもり含んでおり，<strong>重厚長大過ぎる</strong>（割り切り）．</p>\n\n<p><strong>Vue.jsが総合的に判断してベスト</strong>だろう．<br>\n詳細は省くが，メリットは以下の通り．<br>\n・とっつきやすさ<br>\n・単一ファイルコンポーネント<code>*.vue</code>（html, css, jsを一ファイルにまとめられる）<br>\n・日本語ドキュメントが充実<br>\n・それなりの知名度，将来性<br>\n・必要に駆られた際の拡張性<br>\n元Googlerが中心人物のため，Google教徒の我々にとっても安心である．</p>\n\n<p>一時期LAMPスタックという表現に則ってFIREスタックという表現が提唱されたが，自分は更に推し進めて<strong>FiVeスタック</strong>を提唱したい．</p>\n\n<h1>\n<span id=\"fiveスタック\" class=\"fragment\"></span><a href=\"#five%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF\"><i class=\"fa fa-link\"></i></a>FiVeスタック</h1>\n\n<p><strong>Firebase + Vue.js</strong>である．</p>\n\n<p>元ネタのFIREスタックはFirebase + Interface + Reactorであるが，</p>\n\n<p>Interfaceとは，ユーザとのインターフェースである．<br>\njsのフレームワークや，ネイティブアプリを含むこともある．<br>\n上述の通りVue.jsを推す．</p>\n\n<p>Reactorとは，サーバサイドの処理である．<br>\n現在は<a href=\"https://firebase.google.com/products/functions/\" rel=\"nofollow noopener\" target=\"_blank\">Firebase内にも用意されている</a>ため，略語としてFirebaseに包含できてしまう．</p>\n\n<p>つまるところ，<strong>FiVeスタック</strong>である．</p>\n\n<h2>\n<span id=\"ちなみにvue-material\" class=\"fragment\"></span><a href=\"#%E3%81%A1%E3%81%AA%E3%81%BF%E3%81%ABvue-material\"><i class=\"fa fa-link\"></i></a>ちなみに：vue-material</h2>\n\n<p>Vue.jsでmaterial designを使う場合，<a href=\"http://vuematerial.io/\" rel=\"nofollow noopener\" target=\"_blank\">vue-material</a>が便利である．<br>\n<strong>神楽坂やちまはvue-materialで唯一のロゴ掲載スポンサーです（ステマ）</strong>．</p>\n\n<p>…と，だいぶ話も逸れてしまった．<br>\n閑話休題．<br>\nこれまでの内容を踏まえつつ，どのようなサービスに使いやすいか使いにくいかを解説したい．</p>\n\n<h1>\n<span id=\"サービスの向き不向き\" class=\"fragment\"></span><a href=\"#%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%81%AE%E5%90%91%E3%81%8D%E4%B8%8D%E5%90%91%E3%81%8D\"><i class=\"fa fa-link\"></i></a>サービスの向き不向き</h1>\n\n<p>もちろん，Firebaseも万能ではない．</p>\n\n<p>全体的に「細かい所は別に気にしなくてよくない？」という思想に基づいている（割り切り）．<br>\n厳密性をウリにするような，<strong>企業や研究向けサービスの一部には向かない</strong>だろう．<br>\nクエリが貧弱なので高度な分析なども苦手で，そういった意味でも使いにくい．</p>\n\n<p>あるいは初出ではあるが，レイテンシもめちゃくちゃ低いというわけではない．<br>\n（WebSocketなので<a href=\"http://blog.arungupta.me/rest-vs-websocket-comparison-benchmarks/\" rel=\"nofollow noopener\" target=\"_blank\">RESTと比べて速い</a>のは確か）<br>\n格闘ゲームやFirst Person Shootingのような，<strong>わずかな遅延が致命的となるゲームも向かない</strong>．</p>\n\n<p>しかし，これらに含まれない大半のサービスでは，Firebaseの特徴がいずれかの部分でメリットとなるはずだ．<br>\n（但し多くの人にとっては多少の学習コストが要るだろうが）<br>\n本質的に，MySQLを置き換えるだけの可能性は十分に秘めている．<br>\n（だからFiVeスタックを提唱したのだ）</p>\n\n<p>そして兎にも角にも，まず気をつけるべきは<br>\n<strong>「割り切り」</strong><br>\n<strong>「ユーザの見えるままに」</strong><br>\nである．</p>\n\n<p>「dbはツリー状」<br>\n「ノード以下まるごとread」<br>\n「連番や配列は使わない」<br>\n「一貫性のある同時書き込み」<br>\nを意識しつつ，まずは<br>\n<strong>「割り切り」</strong><br>\n<strong>「ユーザの見えるままに」</strong><br>\nである．</p>\n\n<p>しかし大事な話を忘れていた．<br>\n価格を含めた上で，そもそもFirebaseは採用に値するのだろうか？</p>\n\n<h1>\n<span id=\"でもお高いんでしょうやっぱりmysqlのほうが\" class=\"fragment\"></span><a href=\"#%E3%81%A7%E3%82%82%E3%81%8A%E9%AB%98%E3%81%84%E3%82%93%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%82%84%E3%81%A3%E3%81%B1%E3%82%8Amysql%E3%81%AE%E3%81%BB%E3%81%86%E3%81%8C\"><i class=\"fa fa-link\"></i></a>「でもお高いんでしょう？」「やっぱりMySQLのほうが…」</h1>\n\n<p>ここらの話はGDG DevFest Tokyo 2017で登壇して話すので，ぜひいらして欲しい．<br>\n<a href=\"https://tokyo.gdgjapan.org/schedule/day1?sessionId=126\" rel=\"nofollow noopener\" target=\"_blank\">大半のウェブサービス/アプリは，Firebaseなら簡単で安いですよ</a>（<strong>11:30- @会議室1</strong>）<br>\n→<a href=\"https://gdg-tokyo.connpass.com/event/66236/\" rel=\"nofollow noopener\" target=\"_blank\">チケット登録</a>←</p>\n\n<p>当記事はあくまでrealtime databaseのベストプラクティスとして踏み込んだ記事であるため，このイベントではより広い視点で解説するつもりである．</p>\n\n<p>他にご質問，ご意見などあればぜひお気軽に．<br>\n<strong>厳しいマサカリもお待ちしております．</strong></p>\n\n<h1>\n<span id=\"todo\" class=\"fragment\"></span><a href=\"#todo\"><i class=\"fa fa-link\"></i></a>todo</h1>\n\n<p>レシピ埋めたい<br>\nそのうちruleについても加筆したい</p>\n\n<h1>\n<span id=\"ついでにコミュニティも紹介\" class=\"fragment\"></span><a href=\"#%E3%81%A4%E3%81%84%E3%81%A7%E3%81%AB%E3%82%B3%E3%83%9F%E3%83%A5%E3%83%8B%E3%83%86%E3%82%A3%E3%82%82%E7%B4%B9%E4%BB%8B\"><i class=\"fa fa-link\"></i></a>ついでにコミュニティも紹介</h1>\n\n<p>今誕生しそうな，Firebaseの日本ユーザグループ<br>\n<a href=\"https://firebase-community.connpass.com/\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\">https://firebase-community.connpass.com/</a></p>\n\n<p>前からGCPのユーザグループにもたむろっていた（FirebaseはGoogleなので）<br>\n<a href=\"http://gcpug.jp/\" class=\"autolink\" rel=\"nofollow noopener\" target=\"_blank\">http://gcpug.jp/</a></p>\n\n<h1>\n<span id=\"参考記事\" class=\"fragment\"></span><a href=\"#%E5%8F%82%E8%80%83%E8%A8%98%E4%BA%8B\"><i class=\"fa fa-link\"></i></a>参考記事</h1>\n\n<p><a href=\"https://medium.freecodecamp.org/firebase-5-way-too-common-misconceptions-93b843ee1b93\" rel=\"nofollow noopener\" target=\"_blank\">Firebase: 5 way-too-common misconceptions</a><br>\n　（記事最後のフォームより，<strong>ベストプラクティスのチェックリスト</strong>がPDFで入手できる）<br>\n<a href=\"https://www.youtube.com/watch?v=WacqhiI-g_o&amp;list=PLl-K7zZEsYLlP-k-RKFa7RyNPa9_wCH2s\" rel=\"nofollow noopener\" target=\"_blank\">The Firebase Database For SQL Developers</a>（公式youtube．<strong>非常におすすめ</strong>，日本語字幕あり）<br>\n<a href=\"https://howtofirebase.com/firebase-data-modeling-939585ade7f4\" rel=\"nofollow noopener\" target=\"_blank\">Firebase Data Modeling</a><br>\n<a href=\"https://medium.com/@CodeAndBiscuits/best-practices-for-firebase-realtime-database-development-14e8fd133d44\" rel=\"nofollow noopener\" target=\"_blank\">Best Practices for Firebase Realtime Database Development</a><br>\n<a href=\"https://medium.com/@leetheguy/firebase-pros-and-cons-ce37c766190a\" rel=\"nofollow noopener\" target=\"_blank\">Firebase Pros and Cons</a></p>\n\n<p>　</p>\n\n<p>　</p>\n\n<p>└(・∀・)┘ﾔﾘｨ!</p>\n\n<p>　</p>\n\n<p>　</p>\n\n<p>　</p>\n",
  "body": "Firebaseのrealtime databaseはいわゆるNoSQLであり，馴染みが薄い人が多いとともに，一般に流布している情報はふわっとしていてわかりづらい．\n山に篭って修行していたらある程度知見が溜まってきたため，下山して共有する．\n\n**追記：**\n新しいdbが発表されたので雑感書きました．\n[Firebase RTDB + GCP datastore = Firestoreについて第一印象](https://qiita.com/Yatima/items/54ea22d0cea1acc6cbcb)\n\n# tl;dr\n**割り切れ！**\n**ユーザの見えるままに作れ！**\nそれ以外の細末は下記参照\n\n#大原則その1：割り切り\nこれは特にRDB勢に気をつけていただきたい．\n我々は少し気を抜くと，**つい正規化したがり屋さん**になってしまう．\n（その意味では，むしろ開発経験が少ない人のほうが習得しやすいかもしれない）\n\nFirebaseにおいて**正規化はほぼ無駄**と思ってもらっていい．\n（理由は後述）\n頑として非正規化を貫くべきだ（割り切り）．\n\nでは，どう非正規化しろと言うのか．\n巷では良く「ネストを浅くしろ」だの「非正規化しろ」だの言われるが，**どのくらいどうすりゃいいんだよ！**\n\n#大原則その2：ユーザの見えるままに設計する\n\nこれである．\nだいたいまずこれで解決できる．\n\nつまりまず**ビューありき**なのだ（割り切り）．\n**dbを先に設計してはならない．**\n（ビューを変更するときどうするか，は後述）\n\nなぜそうしたほうがいいのか？\n\n##コードはシンプルなほうがいい\n\n当然と言えば当然である．\nスパゲッティ遊びしたい人は少数だろう．\n\n実は**ビューありきでdb設計することによって，コードをシンプルにできる**のだ．\n\n勘のいいかたはおわかりだろうが，dbからread後の処理が最低限で済む．\nある意味[時間と空間のトレードオフ](https://ja.wikipedia.org/wiki/%E6%99%82%E9%96%93%E3%81%A8%E7%A9%BA%E9%96%93%E3%81%AE%E3%83%88%E3%83%AC%E3%83%BC%E3%83%89%E3%82%AA%E3%83%95)に近いものと思って良いだろう．\n\n（知らない人には申し訳ないが）js界隈で話題になりがちなVuexやFlux, Reduxのような状態管理もほぼ不要となる（割り切り．詳細後述）．\n\nあるいはもっと深い理由として，こんなものがある．\n\n## システム全体としての効率化\n\n実ユーザにおいては，圧倒的に書き込み数＜＜読み込み数である．\n従って，効率化する（システム全体のパフォーマンスを上げる）ためには，なるべく**読み込みをスピーディにするのが理に適っている**．\n\n極端にも見える「ユーザの見えるままに」アプローチが確立された背景として，このようなことが挙げられるわけだ．\nこれらを踏まえると，むしろ従来の考え方を持ち込むのは害悪にしかならないことがわかる（割り切り）．\n\n「ユーザの見えるままに」を踏まえたところで，もう少し細かい原則を見ていこう．\n#原則\n\n##原則その1：dbはツリー状\n\njson形式である．\nというのは自明だが，key内にスラッシュが含まれていた場合は，その階層まで潜ると解釈される．\n\n```json:slashed.json\n{\"users/XXXXX/name\": \"yatima\"}\n```\nとwriteすると\n\n```json:nested.json\n{\n  \"users\": {\n    \"XXXXX\": {\n      \"name\": \"yatima\"\n    }\n  }\n}\n```\nとして反映される．\n\n##原則その2：ノード以下まるごとread\n課金やパフォーマンスとの関与が大きい話ではある（基本的に[read時のダウンロードサイズに対して従量課金](https://firebase.google.com/pricing/)）．\n\nreadでは，`.ref()`で指定したノードそれ以下の全てのデータを取得する．\n\n```js:fetch-good.js\nconst db = firebase.database()\nconst hogeRef = db.ref('hoge')\nhogeRef.on(...省略...)\n```\nとすると，`/hoge/`以下のみを取得する．\n\n```js:fetch-yabai.js\nconst db = firebase.database()\nconst dbRef = db.ref()\ndbRef.child('hoge').on(...省略...)\n```\nとすると全部ごそっと取得することになり，悲しみが生まれる．\n\nただしクエリを含めた場合は，それに該当する分のみ取得される．\n\n\n##原則その3：連番は使わない\n例えばカウンタなどで，ほぼ同時にwriteが行われたとすると，残念なことになる．\n（一人目が書き込み終わる前に二人目が読み込んでしまうと，二人ともカウンタを1増やしたつもりが最終的に1しか増えない）\n`.push()`を使うと，**一意なIDをkeyとして書き込み**できる．\n\n```js:push.js\nconst db = firebase.database()\nconst hogeRef = db.ref('hoge')\nhogeRef.push('fuga')\n```\nと書き込むと\n\n```json:db.json\n{\n  \"hoge\": {\n    \"<XXX-unique-id-XXX>\": \"fuga\"\n  }\n}\n```\nとなる．\n\n逆に言えば，`.push()`を使わない場合は**変に上書きされても問題ない前提で**開発すべきである．\n\n##原則その3.1：配列を使わない\nその3と似た理由で，配列（Array）は推奨されない．\n連想配列（Object）に自動で変換されるが，その際に**keyが連番で割り当てられてしまう**からである．\n\n##原則その4：一貫性のある同時書き込み\n単に**同時書き込みするだけで一貫性が保たれる**仕様である．\n\n```js:multi-path-write.js\nconst db = firebase.database()\nconst dbRef = db.ref()\n\nconst newPost = {\n  hoge: \"fuga\"\n}\nlet updates = {}\nupdates['foo'] = newPost\nupdates['bar'] = newPost\ndbRef.update(updates)\n```\nとすると\n\n```json:db.json\n{\n  \"foo\": {\n    \"hoge\": \"fuga\"\n  },\n  \"bar\": {\n    \"hoge\": \"fuga\"\n  }\n}\n```\nとなる．\nサーバ側でvalidateすることも可能だが，不要だとは思われる．一応示しておく；\n\n```json:consistency.rules.json\n{\n  \"test\": {\n    \".write\": \"true\",\n    \"foo\": {\n      \".validate\": \"true\"\n    },\n    \"bar\": {\n      \".validate\": \"newData.val() == newData.parent().child('foo').val()\"\n    }\n  }\n}\n```\n間違っても**`.transaction()`など使ってはならない**．\n（一ノードに対してしか使えない＝rootに近いノードを指定するハメになる，そして[トランザクションはreadが発生](https://firebase.google.com/docs/reference/js/firebase.database.Reference#transaction)する ⇒ 諭吉ジャブジャブ，性能にも影響）\n\nと，比較的重要な原則についても紹介してきたが，いずれにせよあくまで大原則に沿った話である．\n大原則が通用しない場合はどうすべきだろうか．\n\n# 大原則が通用しない時\n\n##ビューが強く動的に生成される\nここでの動的とは，静的ファイルが準備されていないという程度の意味ではない．\n検索のような，ユーザの入力を元にビューを変化させたい，そういったニュアンスである．\n\n###検索\n検索には，[Algolia](https://www.algolia.com/)という外部サービスを利用する（割り切り）．\nFirebase公式より[連携サンプル](https://github.com/firebase/functions-samples/tree/master/fulltext-search)も提示されている．\nただしどうやらこのサービスはORやワイルドカードなどは使えないように見える．\n\n他にも[Flashlight](https://github.com/firebase/flashlight)というElasticSearchとの連携があったりなかったりする．\nワイルドカードは使えるとのことだが，公開されているサンプルはうまく動かない．\n\n###フィルタ\nフィルタに関しては内部で解決可能と思われる．\n基本的にはフィルタのパターン数に応じ対策も変わる．\nざっくり言って，\n\nフィルタのパターン数が多いならば，インデックスを貼る．\n必要があればクライアント側で集合演算も行う．\n（ANDのみならインデックス貼りまくるだけで可能だが，ORがあると厳しい）\nJavaScriptなら[lodash](https://lodash.com/docs/4.17.4)など使うと良い．\n\nフィルタのパターン数がそこまで多くないならば，クエリを駆使する．\nクエリについては，公式で良い解説動画がある（日本語字幕付き）．\n[Common SQL Queries converted for the Firebase Database - The Firebase Database For SQL Developers #4](https://youtu.be/sKFLI5FOOHs?t=9m2s)\nhackyな手法にも見えるが，性能に大きな影響を与えないためのFirebaseの流儀である．\n\n\n詳細は後述しよう．\n\n##そもそもビューがない\nもし[Functions](https://firebase.google.com/products/functions/)や他サーバなどから機械的にreadする必要がある場合は，「readする時使いやすいように」で良いと思われる．\nなるべく事前に準備しておくという意味で，「ユーザの見えるままに」とは共通する．\n\n機械によるreadもなく，保存自体が主な目的の場合は（ログなど？），まぁ好きにしたらいい．\n\n#レシピ（加筆中）\n##カウンタ\nIDを数える．\n##ページネーション\nクエリで良い．\n\n##フィルタ\n\n\n##検索\n\n\n#よく言われるアレ（気付き次第追記）\n\n##「ビューとdbを密結合させたらビューを変更する時に不便」\n多くは見た目の変更で，扱うデータ自体が変更されることは少ないだろう．\n変更されたところで，構造を修正する**バッチを回せば済む**話だ（割り切り）．\n\n##「非正規化が理想なのはわかるけど，でも現実的には正規化したほうがいいよね」\nこれもなるべくなら避けるべきだ（割り切り）．\nというより，上述した特殊な場合以外は現実的に問題ないはずである．\n\n再度になるが，これまで培ってきた感覚で「正規化したほうがよさそう」は避けたほうが良い．\nコードが複雑になり，パフォーマンスにも影響が出かねない．\n\n##「平坦化しろ」\n自分が検証した限りでは，単にdbのネストが深いからといって，パフォーマンスが落ちることはなさそうである．\nそのため，「平坦化する」ということ自体をメインの目標に掲げるのは本質的でない．\n\n目指すはあくまで「ユーザの見えるままに」とすべきである．\n\n「ネストの度に検索がかかるのでは」と思ったかたは鋭い．\nRDBをわかっていらっしゃる．\n\nrealtime databaseでは，jsonのkeyに対してはインデックスが貼られるのだ．\nvalueに対しても，インデックスを指定して貼ることが可能（性能に影響するとアラート出るので，それからで遅くない）．\n\nやはりあくまで中心は「ユーザの見えるままに」である．\n\n##「クエリが貧弱」\nおわかりのかたもいると思うが，そもそも基本的にクエリは最低限でよいのだ．\ndbをreadした時点で，ビューに即した形になっているのだから．\n\n##「値段高い」\n[のちほど](https://qiita.com/Yatima/items/8a54acc8fda3e5fce741#%E3%81%A7%E3%82%82%E3%81%8A%E9%AB%98%E3%81%84%E3%82%93%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%82%84%E3%81%A3%E3%81%B1%E3%82%8Amysql%E3%81%AE%E3%81%BB%E3%81%86%E3%81%8C)．\n\n##「PHPと組み合わせたい」\nなるべく避けるべき（割り切り）．\n\n既存の技術を使わないのはもったいない，あるいは不安と思うかもしれない．\nしかしFirebaseはシンプルなシステム構成にしてこそ真価が発揮される．\n**連携間の相性に悩まされることがなくなる**わけだ．\nあるいは**データ変換やAPIなど余計なことに煩わされなくなる**．\n当記事に記すような考え方が身についてしまえば，**学習コストも低い**．\n\nぜひ0から始める気持ちで臨んでほしい（割り切り）．\nもちろん，RubyやPythonだろうが同様である．\n\n#よく言われないアレ\n\n##tips集\n\n###削除時にはnullをwriteする\n`.set()`や`.update()`，`.push()`でundefinedは送れない．\n`.remove()`もあるが，**複数箇所の削除はできない**のでいまいち．\n\n###一度のみのreadには`.once()`\n上記の通りである．\n\n###クエリを使うなら`child_added`\nread時には`value`を使う（例えば`.on('value', ...)`のように）と手軽のように思えるが，実際は`child_added`のほうが良い．\n後者ならば，[**順番の整った状態で取得できる**](https://howtofirebase.com/firebase-data-modeling-939585ade7f4)ためである．\n前者だとクライアント側で並び替えする必要がある．\n\n`child_changed`などもいちいち書かなければならない？\n例えば[Vuefire](https://github.com/vuejs/vuefire)のような，フレームワークと紐付けしてくれる便利なライブラリがある．\n\n\n##正規化は無駄\n先に謝っておく．無駄は言い過ぎた．\nしかし総じてメリットが上回ることは多くないと思われる．\n\n慣れ以外でのメリットは，高々，容量を節約できるくらいと思われる．\n正規化したところでクエリが貧弱なため，まともに使うには苦労する．\nこの後に示す，グローバル的な状態管理も欲しくなってくる．\nコードが複雑化するのは代償として大きい．\n\n##状態管理は不要\nビューに即したデータ構造を持たせるのだから，基本的にはVuexやFlux, Reduxのような状態管理（いろいろな場面でデータを共有する仕組み）は不要．\nせいぜいユーザ情報程度だろう．\n\nfirebase自体もローカルでデータ保持することを考えると，無駄が多い．\n\n##ベストなjsフレームワーク\ndbの話なのにjsのフレームワークまで踏み込むのもアレだが，ビューとも密接な関係にあるため触れておく．\n\n公式ではAngularが話題に挙がりやすいが，上記の状態管理機能などももりもり含んでおり，**重厚長大過ぎる**（割り切り）．\n\n**Vue.jsが総合的に判断してベスト**だろう．\n詳細は省くが，メリットは以下の通り．\n・とっつきやすさ\n・単一ファイルコンポーネント`*.vue`（html, css, jsを一ファイルにまとめられる）\n・日本語ドキュメントが充実\n・それなりの知名度，将来性\n・必要に駆られた際の拡張性\n元Googlerが中心人物のため，Google教徒の我々にとっても安心である．\n\n一時期LAMPスタックという表現に則ってFIREスタックという表現が提唱されたが，自分は更に推し進めて**FiVeスタック**を提唱したい．\n#FiVeスタック\n**Firebase + Vue.js**である．\n\n元ネタのFIREスタックはFirebase + Interface + Reactorであるが，\n\nInterfaceとは，ユーザとのインターフェースである．\njsのフレームワークや，ネイティブアプリを含むこともある．\n上述の通りVue.jsを推す．\n\nReactorとは，サーバサイドの処理である．\n現在は[Firebase内にも用意されている](https://firebase.google.com/products/functions/)ため，略語としてFirebaseに包含できてしまう．\n\nつまるところ，**FiVeスタック**である．\n\n##ちなみに：vue-material\nVue.jsでmaterial designを使う場合，[vue-material](http://vuematerial.io/)が便利である．\n**神楽坂やちまはvue-materialで唯一のロゴ掲載スポンサーです（ステマ）**．\n\n…と，だいぶ話も逸れてしまった．\n閑話休題．\nこれまでの内容を踏まえつつ，どのようなサービスに使いやすいか使いにくいかを解説したい．\n\n#サービスの向き不向き\nもちろん，Firebaseも万能ではない．\n\n全体的に「細かい所は別に気にしなくてよくない？」という思想に基づいている（割り切り）．\n厳密性をウリにするような，**企業や研究向けサービスの一部には向かない**だろう．\nクエリが貧弱なので高度な分析なども苦手で，そういった意味でも使いにくい．\n\nあるいは初出ではあるが，レイテンシもめちゃくちゃ低いというわけではない．\n（WebSocketなので[RESTと比べて速い](http://blog.arungupta.me/rest-vs-websocket-comparison-benchmarks/)のは確か）\n格闘ゲームやFirst Person Shootingのような，**わずかな遅延が致命的となるゲームも向かない**．\n\nしかし，これらに含まれない大半のサービスでは，Firebaseの特徴がいずれかの部分でメリットとなるはずだ．\n（但し多くの人にとっては多少の学習コストが要るだろうが）\n本質的に，MySQLを置き換えるだけの可能性は十分に秘めている．\n（だからFiVeスタックを提唱したのだ）\n\nそして兎にも角にも，まず気をつけるべきは\n**「割り切り」**\n**「ユーザの見えるままに」**\nである．\n\n「dbはツリー状」\n「ノード以下まるごとread」\n「連番や配列は使わない」\n「一貫性のある同時書き込み」\nを意識しつつ，まずは\n**「割り切り」**\n**「ユーザの見えるままに」**\nである．\n\nしかし大事な話を忘れていた．\n価格を含めた上で，そもそもFirebaseは採用に値するのだろうか？\n\n# 「でもお高いんでしょう？」「やっぱりMySQLのほうが…」\n\nここらの話はGDG DevFest Tokyo 2017で登壇して話すので，ぜひいらして欲しい．\n[大半のウェブサービス/アプリは，Firebaseなら簡単で安いですよ](https://tokyo.gdgjapan.org/schedule/day1?sessionId=126)（**11:30- @会議室1**）\n→[チケット登録](https://gdg-tokyo.connpass.com/event/66236/)←\n\n当記事はあくまでrealtime databaseのベストプラクティスとして踏み込んだ記事であるため，このイベントではより広い視点で解説するつもりである．\n\n他にご質問，ご意見などあればぜひお気軽に．\n**厳しいマサカリもお待ちしております．**\n\n#todo\nレシピ埋めたい\nそのうちruleについても加筆したい\n\n#ついでにコミュニティも紹介\n今誕生しそうな，Firebaseの日本ユーザグループ\nhttps://firebase-community.connpass.com/\n\n前からGCPのユーザグループにもたむろっていた（FirebaseはGoogleなので）\nhttp://gcpug.jp/\n\n#参考記事\n[Firebase: 5 way-too-common misconceptions](https://medium.freecodecamp.org/firebase-5-way-too-common-misconceptions-93b843ee1b93)\n　（記事最後のフォームより，**ベストプラクティスのチェックリスト**がPDFで入手できる）\n[The Firebase Database For SQL Developers](https://www.youtube.com/watch?v=WacqhiI-g_o&list=PLl-K7zZEsYLlP-k-RKFa7RyNPa9_wCH2s)（公式youtube．**非常におすすめ**，日本語字幕あり）\n[Firebase Data Modeling](https://howtofirebase.com/firebase-data-modeling-939585ade7f4)\n[Best Practices for Firebase Realtime Database Development](https://medium.com/@CodeAndBiscuits/best-practices-for-firebase-realtime-database-development-14e8fd133d44)\n[Firebase Pros and Cons](https://medium.com/@leetheguy/firebase-pros-and-cons-ce37c766190a)\n\n　\n\n　\n\n└(・∀・)┘ﾔﾘｨ!\n\n　\n\n　\n\n　\n",
  "coediting": false,
  "comments_count": 6,
  "created_at": "2017-10-03T23:08:40+09:00",
  "group": null,
  "id": "8a54acc8fda3e5fce741",
  "likes_count": 168,
  "private": false,
  "reactions_count": 0,
  "tags": [
    {
      "name": "Android",
      "versions": []
    },
    {
      "name": "iOS",
      "versions": []
    },
    {
      "name": "AngularJS",
      "versions": []
    },
    {
      "name": "vue.js",
      "versions": []
    },
    {
      "name": "Firebase",
      "versions": []
    }
  ],
  "title": "結局Firebaseのdbでは何に気をつけるべきか？少しマニアックな内容も含め，わかりやすく説明する(realtime database)",
  "updated_at": "2017-11-10T20:58:10+09:00",
  "url": "https://qiita.com/Yatima/items/8a54acc8fda3e5fce741",
  "user": {
    "description": "",
    "facebook_id": "yatima.kagurazaka",
    "followees_count": 22,
    "followers_count": 129,
    "github_login_name": "Yatima-Kagurazaka",
    "id": "Yatima",
    "items_count": 25,
    "linkedin_id": "",
    "location": "",
    "name": "",
    "organization": "株式会社みんコレ",
    "permanent_id": 17440,
    "profile_image_url": "https://qiita-image-store.s3.amazonaws.com/0/17440/profile-images/1473682159",
    "twitter_screen_name": "Yatima_K",
    "website_url": ""
  },
  "page_views_count": null
}